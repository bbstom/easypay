# 多节点数据处理策略

## 核心原则

**单节点查询策略**：系统在任何时刻只使用一个节点进行查询，不会同时查询多个节点。

## 工作机制

### 1. 节点选择

系统按以下顺序选择节点：

```
启用的节点1 → 启用的节点2 → 启用的节点3 → 失败抛出错误
```

**重要变更**：系统不再使用内置备用节点，只使用您配置的节点。

**示例**：
- 配置了 TronGrid、ZAN 两个节点
- 系统首先尝试连接 TronGrid
- 如果 TronGrid 连接成功，所有查询都使用 TronGrid
- 如果 TronGrid 失败，尝试连接 ZAN
- 如果所有配置的节点都失败，系统会抛出错误

### 2. 节点切换

**触发条件**：
- 当前节点连接失败
- API 请求超时（30秒）
- 返回 429 限流错误
- 返回 5xx 服务器错误

**切换流程**：
```javascript
当前节点失败 → 尝试下一个启用的节点 → 连接成功 → 使用新节点
```

**重要**：切换后，所有后续查询都使用新节点，直到新节点也失败。

### 3. 数据一致性

由于只使用单个节点查询，数据来源是一致的：

- ✅ 同一时刻所有数据来自同一个节点
- ✅ 避免不同节点数据不一致的问题
- ✅ 简化错误处理逻辑

### 4. 查询类型

所有 TRON 链上查询都使用当前连接的节点：

**余额查询**：
```javascript
const balance = await tronWeb.trx.getBalance(address);
```

**USDT 余额查询**：
```javascript
const contract = await tronWeb.contract().at(usdtContract);
const balance = await contract.balanceOf(address).call();
```

**账户资源查询**：
```javascript
const resources = await tronWeb.trx.getAccountResources(address);
```

**交易查询**：
```javascript
const tx = await tronWeb.trx.getTransaction(txHash);
const txInfo = await tronWeb.trx.getTransactionInfo(txHash);
```

**转账操作**：
```javascript
const tx = await contract.transfer(toAddress, amount).send();
```

## 实现细节

### 初始化流程

```javascript
async initialize() {
  // 1. 加载配置的节点
  this.apiNodes = [
    { url: 'https://api.trongrid.io', apiKey: 'xxx', name: 'TronGrid' },
    { url: 'https://api.zan.top/...', apiKey: '', name: 'ZAN' }
  ];

  // 2. 按顺序尝试连接
  for (let i = 0; i < this.apiNodes.length; i++) {
    const connected = await this.connectToNode(i, privateKey);
    if (connected) {
      this.currentNodeIndex = i;
      this.initialized = true;
      return;
    }
  }

  // 3. 所有节点都失败，抛出错误
  throw new Error('所有配置的 API 节点均不可用，请检查节点配置');
}
```

### 连接节点

```javascript
async connectToNode(nodeIndex, privateKey) {
  const node = this.apiNodes[nodeIndex];
  
  // 创建 TronWeb 实例
  const tronWebConfig = {
    fullHost: node.url,
    privateKey: privateKey
  };

  // 如果有 API Key，添加到 headers
  if (node.apiKey) {
    tronWebConfig.headers = {
      'TRON-PRO-API-KEY': node.apiKey
    };
  }

  this.tronWeb = new TronWeb.TronWeb(tronWebConfig);
  this.currentApiUrl = node.url;
  this.currentNodeIndex = nodeIndex;

  // 测试连接
  await this.tronWeb.trx.getBalance(address);
  
  return true;
}
```

### 查询示例

```javascript
// 所有查询都使用 this.tronWeb
async getBalance(address) {
  // 使用当前连接的节点
  const balance = await this.tronWeb.trx.getBalance(address);
  return balance / 1000000;
}

async getUSDTBalance(address) {
  // 使用当前连接的节点
  const contract = await this.tronWeb.contract().at(usdtContract);
  const balance = await contract.balanceOf(address).call();
  return balance / 1000000;
}
```

## 为什么不使用多节点并行查询？

### 1. 数据一致性问题

不同节点可能处于不同的区块高度：

```
TronGrid:  区块 #12345678
ZAN:       区块 #12345680
TronScan:  区块 #12345675
```

如果并行查询，可能得到不一致的数据：
- 节点A 显示余额 100 USDT
- 节点B 显示余额 95 USDT（还没同步最新交易）
- 节点C 显示余额 105 USDT（已同步但另一笔交易）

### 2. 复杂的数据合并逻辑

需要决定：
- 使用哪个节点的数据？
- 如何处理冲突？
- 如何判断哪个数据更准确？

### 3. 增加 API 请求次数

- 单节点：1 次请求
- 三节点并行：3 次请求
- 可能更快触发限流

### 4. 增加系统复杂度

- 需要实现数据合并逻辑
- 需要处理部分节点失败的情况
- 需要更复杂的错误处理

## 单节点策略的优势

### 1. 简单可靠

- 逻辑清晰，易于理解和维护
- 数据来源单一，避免冲突
- 错误处理简单

### 2. 高可用性

- 多个节点作为备份
- 自动故障切换
- 不依赖单一节点

### 3. 性能优化

- 减少不必要的 API 请求
- 避免数据合并开销
- 更快的响应速度

### 4. 成本控制

- 减少 API 调用次数
- 降低限流风险
- 节省 API 配额

## 监控和诊断

### 查看当前节点

在"状态监控"中可以看到：

```
API 节点: TronGrid [已连接]
https://api.trongrid.io
```

### 日志输出

```
🔗 已加载 3 个 API 节点
   1. TronGrid: https://api.trongrid.io (有 API Key)
   2. ZAN: https://api.zan.top/... (有 API Key)
   3. TronScan: https://apilist.tronscan.org
🔗 尝试连接节点 1/3: TronGrid
✅ 节点连接成功: TronGrid
📍 当前节点: https://api.trongrid.io
```

### 切换日志

```
❌ API 调用失败: 请求超时
🔄 尝试连接节点 2/3: ZAN
✅ 节点连接成功: ZAN
📍 当前节点: https://api.zan.top/...
```

## 最佳实践

### 1. 节点配置

- 至少配置 2 个节点
- 优先使用有 API Key 的节点
- 将最稳定的节点放在第一位

### 2. API Key 管理

- 为每个节点申请独立的 API Key
- 避免共享 API Key
- 定期检查使用情况

### 3. 监控

- 定期查看当前使用的节点
- 关注节点切换频率
- 如果频繁切换，检查节点稳定性

### 4. 故障处理

- 节点失败时会自动切换
- 无需手动干预
- 查看日志了解切换原因

## 总结

**核心策略**：单节点查询 + 自动故障切换

**优势**：
- ✅ 数据一致性
- ✅ 简单可靠
- ✅ 高可用性
- ✅ 性能优化

**适用场景**：
- ✅ 所有 TRON 链上查询
- ✅ 余额查询
- ✅ 交易查询
- ✅ 转账操作

这种策略在保证高可用性的同时，避免了多节点并行查询带来的复杂性和数据一致性问题。
